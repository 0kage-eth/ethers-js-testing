/**
 * In this file, I deploy and play around with a mock ERC20 contract
 * I follow along the example in ethers.js
 * https://docs.ethers.io/v5/api/contract/example/
 * Have added more cases as I play around with various methods in ethers.jhs
 */

const { ethers } = require("ethers")
const { erc20_abi, erc20_bytecode } = require("../contract-abis/erc20_abi")
require("dotenv").config()

const RINKEBY_RPC_URL = process.env.RINKEBY_RPC_URL
const PRIVATE_KEY = process.env.PRIVATE_KEY
const RECEPIENT_KEY = process.env.PRIVATE_KEY_2

const deployedContractAddress = "0x45D7bD56Fe83525484Ea4722df47dE704e350254"

const keyNotes = () => {
    console.log(
        "In contracts.js & contract-factory.js we learnt how to deploy and call functions in a contract"
    )

    console.log(
        "In this example, I will put it all together for a ERC 20 contract. Here ayre following steps"
    )

    console.log("STEP 1: We will deploy a mock ERC20 contract")
    console.log("STEP 2: We will create an instance of this existing contract on chain")
    console.log("STEP 3: We will use functions such as mint(), totalSupply() etc")
    console.log(
        "STEP 4: We will listen to events generated by transactions interacting with our contract"
    )
    console.log("STEP 5: We will filter logs generated onchain for this contract")

    console.log("All steps above complete how we deploy/interact with contracts on-chain")

    console.log(
        "Note that I'm not writing solidity code for this example. Just using boiler plate ERC 20 contract code from existing contracts"
    )
}

/**
 * Using this method to deploy contract
 * For this I'm using a verified contract on rinkeby - copied its abi/bytecode to erc20_abi.js
 */
const deployContract = async () => {
    const contractFactory = new ethers.ContractFactory(erc20_abi, erc20_bytecode)
    const provider = new ethers.providers.JsonRpcProvider(RINKEBY_RPC_URL)
    const signer = new ethers.Wallet(PRIVATE_KEY, provider)

    const contractFactorySigned = contractFactory.connect(signer)
    // Deployed contract - constructor takes 3 arguments (name_, symbole, arguments_) - refer abi
    const contract = await contractFactorySigned.deploy()
    console.log("Contract deployed at address:", contract.address)
}

/** Once contract is deployed in previous step,
 * I use this step to access contract that is deployed
 *
 */

const accessContract = () => {
    console.log("Accessing contract data from blockchain and creating a local instance")
    // By this stage contract is already deployed and deployedAddress populated
    // I will access this contract from Rinkeby network

    /**
     * @dev if no contract deployed, then deploy it first
     * I already deployed contract to 0x45D7bD56Fe83525484Ea4722df47dE704e350254
     * I have hardcoded address - if you deploy contract, please change address accordingly
     */

    if (!deployedContractAddress) {
        deployContract()
    }

    // To create a contract instance, we need the abi, address & wallet

    const provider = new ethers.providers.JsonRpcProvider(RINKEBY_RPC_URL)
    const signer = new ethers.Wallet(PRIVATE_KEY, provider)

    const abi = erc20_abi
    const address = deployedContractAddress

    const erc20Contract = new ethers.Contract(address, abi, signer)
    console.log("ERC20 contract address:", erc20Contract.address)

    return erc20Contract
}

/**
 *
 * @param contract contract object
 * @dev use this to test all get functions in contract
 */
const getContractInfo = async (contract) => {
    console.log("Reading data from blockchain")
    const supply = (await contract.totalSupply()).toString()
    const tokenName = (await contract.name()).toString()
    const symbol = (await contract.symbol()).toString()

    console.log("Calling get functions in the contract...")
    console.log(`Token name: ${tokenName}, symbol: ${symbol} and supply: ${supply}`)
    console.log("Completed reading")
}

/**
 *
 * @param contract contract object that we access to run callStatic methods
 * As you know, callStatic methods allow us to test functions on blockchain without spending gas
 * this includes write functions which are supposed to change state
 * @dev in this exercise, I run mint() function in callStatic mode
 * @dev to generate an error, I also transfer tokens which don't exist
 */
const usingCallStatic = async (contract) => {
    console.log("using call static functions...")
    const provider = new ethers.providers.JsonRpcProvider(RINKEBY_RPC_URL)
    const receiverWallet = new ethers.Wallet(RECEPIENT_KEY, provider)

    try {
        console.log("Running mint() function in callStatic mode - without changing state")

        const txResponse = await contract.callStatic.mint(ethers.utils.parseEther("100"))
        console.log("Transaction response", txResponse)

        // This should lead to an error,
        // supply at the moment is 0 (since mint() does not update state)
        const newBalance = await contract.totalSupply()
        console.log("Balance should continue to be zero (state unchanged):", newBalance.toString())

        // ** Uncomment code inside *** block below - this will give an error on execution
        // we know a txn fails without actually consuming gas

        /****************** */
        // const txResponse2 = await contract.callStatic.transfer(
        //     receiverWallet.address,
        //     ethers.utils.parseEther("100")
        // )

        // console.log("Transaction response", txResponse2)
        /************************* */
    } catch (e) {
        console.log(e)
    }

    console.log("completed call static function..")
}

/** makeTransactions() - we will make changes to state of blockchain
 * @dev run the mint() and transfer() functions and recheck changed state
 */
const makeTransactions = async (contract) => {
    console.log("Initiating mint transactions...")
    const recepient = new ethers.Wallet(RECEPIENT_KEY, contract.provider)

    const oldSupply = await contract.totalSupply()
    console.log("Old supply before minting:", oldSupply.toString())

    console.log("Minting 1 billion new ERC20 tokens...")
    const txResponse = await contract.mint(ethers.utils.parseUnits("1", "gwei"))
    const txReceipt = await txResponse.wait(1) // wait for 1 block & collect receipt

    //just to ensure state is correctly ypdated
    const newSupply = await contract.totalSupply()
    console.log("New supply after minting:", newSupply.toString())

    console.log("Now transfering 1 billion tokens to receipient wallet")

    const recepientBalanceBeforeTransfer = await recepient.getBalance()
    console.log(
        "balance in recepient wallet before transfer",
        recepientBalanceBeforeTransfer.toString()
    )
    const transferResponse = await contract.transfer(
        recepient.address,
        ethers.utils.parseUnits("1", "gwei")
    )
    await transferResponse.wait(1)

    const recepientBalanceAfterTransfer = await recepient.getBalance()
    console.log(
        "balance in recepient wallet before transfer",
        recepientBalanceAfterTransfer.toString()
    )
    console.log("Completed mint transactions")
}

/** In listenToEvents(), I will listen to various events */
const listenToEvents = (contract) => {
    console.log("setting up event listeners")

    console.log("Every time a mint() is called, a Transfer event is emitted")

    console.log("Setup a event listener for a transfer event")

    const filterOnMint = "Transfer(address,address,uint256)"
    const transferFilter = contract.filters[filterOnMint]

    console.log("listening to transfer filter event")
    const captureLogs = new Promise((resolve, reject) => {
        contract.once(transferFilter, (txn) => {
            const [from, to, value] = txn.args
            console.log("Caught the mint event...")
            console.log(`${from}, ${to}, ${value}`)
            // Notice that we get 2 events when we mint()
            // that is because mint is also
            resolve()
        })
    })
}

// In capture logs, I attempt to capture all logs
const captureLogs = async (contract) => {
    console.log("Entering capturing logs...")
    //TO DO
    const transferFilter = contract.filters["Transfer(address,address,uint256)"]

    console.log(">const logs = await contract.queryFilter(transferFilter, -10, 'latest'")
    console.log("filters logs in last 10 blocks from the latest")
    const logs = await contract.queryFilter(transferFilter, -10, "latest")

    logs.map((log, indx) => console.log(`log #${indx}`, log))

    console.log("Logs captured...")
}

const main = async () => {
    try {
        // deployContract()
        const contract = accessContract()
        // getContractInfo(contract)
        // usingCallStatic(contract)
        listenToEvents(contract)
        await makeTransactions(contract)
        // listenToEvents(contract)
        await captureLogs(contract)
    } catch (e) {
        console.log(e)
    }
}

//execute
main()
